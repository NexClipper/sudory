// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package v3

import (
	"fmt"
	"strings"
)

const (
	// FilterOpNaV is a FilterOp of type NaV.
	FilterOpNaV FilterOp = iota
	// FilterOpEQ is a FilterOp of type EQ.
	FilterOpEQ
	// FilterOpNOT is a FilterOp of type NOT.
	FilterOpNOT
	// FilterOpGT is a FilterOp of type GT.
	FilterOpGT
	// FilterOpGTE is a FilterOp of type GTE.
	FilterOpGTE
	// FilterOpLT is a FilterOp of type LT.
	FilterOpLT
	// FilterOpLTE is a FilterOp of type LTE.
	FilterOpLTE
)

const _FilterOpName = "NaVEQNOTGTGTELTLTE"

var _FilterOpNames = []string{
	_FilterOpName[0:3],
	_FilterOpName[3:5],
	_FilterOpName[5:8],
	_FilterOpName[8:10],
	_FilterOpName[10:13],
	_FilterOpName[13:15],
	_FilterOpName[15:18],
}

// FilterOpNames returns a list of possible string values of FilterOp.
func FilterOpNames() []string {
	tmp := make([]string, len(_FilterOpNames))
	copy(tmp, _FilterOpNames)
	return tmp
}

var _FilterOpMap = map[FilterOp]string{
	FilterOpNaV: _FilterOpName[0:3],
	FilterOpEQ:  _FilterOpName[3:5],
	FilterOpNOT: _FilterOpName[5:8],
	FilterOpGT:  _FilterOpName[8:10],
	FilterOpGTE: _FilterOpName[10:13],
	FilterOpLT:  _FilterOpName[13:15],
	FilterOpLTE: _FilterOpName[15:18],
}

// String implements the Stringer interface.
func (x FilterOp) String() string {
	if str, ok := _FilterOpMap[x]; ok {
		return str
	}
	return fmt.Sprintf("FilterOp(%d)", x)
}

var _FilterOpValue = map[string]FilterOp{
	_FilterOpName[0:3]:                    FilterOpNaV,
	strings.ToLower(_FilterOpName[0:3]):   FilterOpNaV,
	_FilterOpName[3:5]:                    FilterOpEQ,
	strings.ToLower(_FilterOpName[3:5]):   FilterOpEQ,
	_FilterOpName[5:8]:                    FilterOpNOT,
	strings.ToLower(_FilterOpName[5:8]):   FilterOpNOT,
	_FilterOpName[8:10]:                   FilterOpGT,
	strings.ToLower(_FilterOpName[8:10]):  FilterOpGT,
	_FilterOpName[10:13]:                  FilterOpGTE,
	strings.ToLower(_FilterOpName[10:13]): FilterOpGTE,
	_FilterOpName[13:15]:                  FilterOpLT,
	strings.ToLower(_FilterOpName[13:15]): FilterOpLT,
	_FilterOpName[15:18]:                  FilterOpLTE,
	strings.ToLower(_FilterOpName[15:18]): FilterOpLTE,
}

// ParseFilterOp attempts to convert a string to a FilterOp.
func ParseFilterOp(name string) (FilterOp, error) {
	if x, ok := _FilterOpValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _FilterOpValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return FilterOp(0), fmt.Errorf("%s is not a valid FilterOp, try [%s]", name, strings.Join(_FilterOpNames, ", "))
}
